<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>InspIRCd: Module Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">InspIRCd
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_module-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Module Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="modules_8h_source.html">modules.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Module:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_module.png" usemap="#Module_map" alt=""/>
  <map id="Module_map" name="Module_map">
<area href="classclassbase.html" alt="classbase" shape="rect" coords="0,0,90,24"/>
<area href="classusecountbase.html" alt="usecountbase" shape="rect" coords="100,0,190,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a83b2c5b16047bc1a89ab9035396fbdd6"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_module.html">Module</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a83b2c5b16047bc1a89ab9035396fbdd6">List</a></td></tr>
<tr class="separator:a83b2c5b16047bc1a89ab9035396fbdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5a240a8a9ab1813b17bcb810b24ceaea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5a240a8a9ab1813b17bcb810b24ceaea">Module</a> ()</td></tr>
<tr class="separator:a5a240a8a9ab1813b17bcb810b24ceaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19e59816d97db07363143c859ad0c10"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab19e59816d97db07363143c859ad0c10">init</a> ()</td></tr>
<tr class="separator:ab19e59816d97db07363143c859ad0c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf4e278594597a19264689a2d14bde0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cull_result.html">CullResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a9cf4e278594597a19264689a2d14bde0">cull</a> ()</td></tr>
<tr class="separator:a9cf4e278594597a19264689a2d14bde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9d9c096786d127590fdd8aa2b7d681"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7c9d9c096786d127590fdd8aa2b7d681">~Module</a> ()</td></tr>
<tr class="separator:a7c9d9c096786d127590fdd8aa2b7d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a2018354cc3e7d01d2ef73fbb95407"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a88a2018354cc3e7d01d2ef73fbb95407">Prioritize</a> ()</td></tr>
<tr class="separator:a88a2018354cc3e7d01d2ef73fbb95407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793782034272562b25f93b7a5b972513"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a793782034272562b25f93b7a5b972513">ReadConfig</a> (<a class="el" href="class_config_status.html">ConfigStatus</a> &amp;status)</td></tr>
<tr class="separator:a793782034272562b25f93b7a5b972513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1cba59ac54d26b4649858b2cfc6aa8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_version.html">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ace1cba59ac54d26b4649858b2cfc6aa8">GetVersion</a> ()=0</td></tr>
<tr class="separator:ace1cba59ac54d26b4649858b2cfc6aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3910edd1a48dfe4db141b04157627a8e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a3910edd1a48dfe4db141b04157627a8e">OnUserConnect</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:a3910edd1a48dfe4db141b04157627a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8387b28516ca01ebbb740325eb40ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5b8387b28516ca01ebbb740325eb40ee">OnUserPreQuit</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, std::string &amp;message, std::string &amp;oper_message)</td></tr>
<tr class="separator:a5b8387b28516ca01ebbb740325eb40ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467945d27be3edec8fbd0de9a37a0c31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a467945d27be3edec8fbd0de9a37a0c31">OnUserQuit</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;message, const std::string &amp;oper_message)</td></tr>
<tr class="separator:a467945d27be3edec8fbd0de9a37a0c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193075c27aee23eb8baf613ed31327b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a193075c27aee23eb8baf613ed31327b4">OnUserDisconnect</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:a193075c27aee23eb8baf613ed31327b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f0a0386640538a817ab4b461d75dba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a90f0a0386640538a817ab4b461d75dba">OnChannelPreDelete</a> (<a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="separator:a90f0a0386640538a817ab4b461d75dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6be01493bcae74002a9e81d3ba3473"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4c6be01493bcae74002a9e81d3ba3473">OnChannelDelete</a> (<a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="separator:a4c6be01493bcae74002a9e81d3ba3473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e65c3401aff9a6c68e2b2f9f2de5dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ae4e65c3401aff9a6c68e2b2f9f2de5dd">OnUserJoin</a> (<a class="el" href="class_membership.html">Membership</a> *memb, bool sync, bool created, CUList &amp;except_list)</td></tr>
<tr class="separator:ae4e65c3401aff9a6c68e2b2f9f2de5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3be3a9518b0ee13a391ae6daffa5553"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af3be3a9518b0ee13a391ae6daffa5553">OnPostJoin</a> (<a class="el" href="class_membership.html">Membership</a> *memb)</td></tr>
<tr class="separator:af3be3a9518b0ee13a391ae6daffa5553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100db8d416d1484716999076880f63d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a100db8d416d1484716999076880f63d5">OnUserPart</a> (<a class="el" href="class_membership.html">Membership</a> *memb, std::string &amp;partmessage, CUList &amp;except_list)</td></tr>
<tr class="separator:a100db8d416d1484716999076880f63d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390969a3664c10646dfe13be95ac016d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a390969a3664c10646dfe13be95ac016d">OnPreRehash</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;parameter)</td></tr>
<tr class="separator:a390969a3664c10646dfe13be95ac016d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae6d16d1fe5d629dce9deedaa0a1b49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aaae6d16d1fe5d629dce9deedaa0a1b49">OnModuleRehash</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;parameter)</td></tr>
<tr class="separator:aaae6d16d1fe5d629dce9deedaa0a1b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d39c9fabab9dea701f4a3ad2cfff37b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7d39c9fabab9dea701f4a3ad2cfff37b">OnSendSnotice</a> (char &amp;snomask, std::string &amp;type, const std::string &amp;message)</td></tr>
<tr class="separator:a7d39c9fabab9dea701f4a3ad2cfff37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35be5f8c388dc8a6e730842f990e0ad9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a35be5f8c388dc8a6e730842f990e0ad9">OnUserPreJoin</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;cname, std::string &amp;privs, const std::string &amp;keygiven)</td></tr>
<tr class="separator:a35be5f8c388dc8a6e730842f990e0ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fb5e86ea38f35095af102f40894c1b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a54fb5e86ea38f35095af102f40894c1b">OnUserPreKick</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_membership.html">Membership</a> *memb, const std::string &amp;reason)</td></tr>
<tr class="separator:a54fb5e86ea38f35095af102f40894c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0c7ca18eadf768e69894f2995b0db7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a0a0c7ca18eadf768e69894f2995b0db7">OnUserKick</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_membership.html">Membership</a> *memb, const std::string &amp;reason, CUList &amp;except_list)</td></tr>
<tr class="separator:a0a0c7ca18eadf768e69894f2995b0db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6f7ea0790f23d6c15ff3daf40b7f48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#afb6f7ea0790f23d6c15ff3daf40b7f48">OnOper</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;opertype)</td></tr>
<tr class="separator:afb6f7ea0790f23d6c15ff3daf40b7f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b2ffd9df24552ff78888a536faceba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ac0b2ffd9df24552ff78888a536faceba">OnPostOper</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;opername, const std::string &amp;opertype)</td></tr>
<tr class="separator:ac0b2ffd9df24552ff78888a536faceba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ce87b25ff0b4ad30f2dc8fed36a2c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ae3ce87b25ff0b4ad30f2dc8fed36a2c7">OnPostDeoper</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="separator:ae3ce87b25ff0b4ad30f2dc8fed36a2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2b1fed6b47eda0305f04426db05baf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a9c2b1fed6b47eda0305f04426db05baf">OnUserPreInvite</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, <a class="el" href="class_channel.html">Channel</a> *channel, time_t timeout)</td></tr>
<tr class="separator:a9c2b1fed6b47eda0305f04426db05baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b0a70a70ae92b80bc3fc7367e35605"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a79b0a70a70ae92b80bc3fc7367e35605">OnUserInvite</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, <a class="el" href="class_channel.html">Channel</a> *channel, time_t timeout, unsigned int notifyrank, CUList &amp;notifyexcepts)</td></tr>
<tr class="separator:a79b0a70a70ae92b80bc3fc7367e35605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13da0a736da61de2a73a36a6714d2b73"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a13da0a736da61de2a73a36a6714d2b73">OnUserPreMessage</a> (<a class="el" href="class_user.html">User</a> *user, const <a class="el" href="class_message_target.html">MessageTarget</a> &amp;target, <a class="el" href="class_message_details.html">MessageDetails</a> &amp;details)</td></tr>
<tr class="separator:a13da0a736da61de2a73a36a6714d2b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c2e173e33c6e288fea2ddc494d7edd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af2c2e173e33c6e288fea2ddc494d7edd">OnBuildNeighborList</a> (<a class="el" href="class_user.html">User</a> *source, IncludeChanList &amp;include_c, std::map&lt; <a class="el" href="class_user.html">User</a> *, bool &gt; &amp;exceptions)</td></tr>
<tr class="separator:af2c2e173e33c6e288fea2ddc494d7edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3553e152e8cb2371f3ad99aeb61b8991"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a3553e152e8cb2371f3ad99aeb61b8991">OnUserPreNick</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, const std::string &amp;newnick)</td></tr>
<tr class="separator:a3553e152e8cb2371f3ad99aeb61b8991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad7a612b402cbbfffea50fefdd8cbe3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a3ad7a612b402cbbfffea50fefdd8cbe3">OnUserPostMessage</a> (<a class="el" href="class_user.html">User</a> *user, const <a class="el" href="class_message_target.html">MessageTarget</a> &amp;target, const <a class="el" href="class_message_details.html">MessageDetails</a> &amp;details)</td></tr>
<tr class="separator:a3ad7a612b402cbbfffea50fefdd8cbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac211481d14d51c64485052ccb1b4b28c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ac211481d14d51c64485052ccb1b4b28c">OnUserMessage</a> (<a class="el" href="class_user.html">User</a> *user, const <a class="el" href="class_message_target.html">MessageTarget</a> &amp;target, const <a class="el" href="class_message_details.html">MessageDetails</a> &amp;details)</td></tr>
<tr class="separator:ac211481d14d51c64485052ccb1b4b28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace99c0beace10bab228c70941e3ead2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ace99c0beace10bab228c70941e3ead2b">OnUserMessageBlocked</a> (<a class="el" href="class_user.html">User</a> *user, const <a class="el" href="class_message_target.html">MessageTarget</a> &amp;target, const <a class="el" href="class_message_details.html">MessageDetails</a> &amp;details)</td></tr>
<tr class="separator:ace99c0beace10bab228c70941e3ead2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa2dac1cd107a0f20f64459b24e9ad7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aeaa2dac1cd107a0f20f64459b24e9ad7">OnMode</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_user.html">User</a> *usertarget, <a class="el" href="class_channel.html">Channel</a> *chantarget, const <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;changelist, ModeParser::ModeProcessFlag processflags)</td></tr>
<tr class="separator:aeaa2dac1cd107a0f20f64459b24e9ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e2a4e731ead980507fd02e0b1f69b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af2e2a4e731ead980507fd02e0b1f69b0">OnDecodeMetaData</a> (<a class="el" href="class_extensible.html">Extensible</a> *target, const std::string &amp;extname, const std::string &amp;extdata)</td></tr>
<tr class="separator:af2e2a4e731ead980507fd02e0b1f69b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6aa4ebe19c22eb32f7a65ecbc74594"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a9f6aa4ebe19c22eb32f7a65ecbc74594">OnChangeHost</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="separator:a9f6aa4ebe19c22eb32f7a65ecbc74594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab863fadc8f2f0c7f2968ac8292d27cd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aab863fadc8f2f0c7f2968ac8292d27cd">OnChangeRealHost</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="separator:aab863fadc8f2f0c7f2968ac8292d27cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b29d59fa658b5d8ccef313270b8cf37"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a1b29d59fa658b5d8ccef313270b8cf37">OnPostChangeRealHost</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="separator:a1b29d59fa658b5d8ccef313270b8cf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9cee26dfdf58c5e001fafedbefc107"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a8e9cee26dfdf58c5e001fafedbefc107">OnChangeRealName</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;real)</td></tr>
<tr class="separator:a8e9cee26dfdf58c5e001fafedbefc107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135ab5a74a236dc4f696191b25efec2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a135ab5a74a236dc4f696191b25efec2b">OnChangeIdent</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;ident)</td></tr>
<tr class="separator:a135ab5a74a236dc4f696191b25efec2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace17c45466526ac93a24c8a7441b59e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ace17c45466526ac93a24c8a7441b59e3">OnAddLine</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_x_line.html">XLine</a> *line)</td></tr>
<tr class="separator:ace17c45466526ac93a24c8a7441b59e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa784e9b35582872ca8228053c93615d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aa784e9b35582872ca8228053c93615d7">OnDelLine</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_x_line.html">XLine</a> *line)</td></tr>
<tr class="separator:aa784e9b35582872ca8228053c93615d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b8a6dd1c8e6f2e8e15eed14a5205e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a33b8a6dd1c8e6f2e8e15eed14a5205e6">OnExpireLine</a> (<a class="el" href="class_x_line.html">XLine</a> *line)</td></tr>
<tr class="separator:a33b8a6dd1c8e6f2e8e15eed14a5205e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3323630e669476ed433b36b6863618"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ace3323630e669476ed433b36b6863618">OnCleanup</a> (<a class="el" href="class_extension_item.html#a033cb646471c0d59024f927bcc34a34b">ExtensionItem::ExtensibleType</a> type, <a class="el" href="class_extensible.html">Extensible</a> *item)</td></tr>
<tr class="separator:ace3323630e669476ed433b36b6863618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35164fe098f2acdec99d3e242e585e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ad35164fe098f2acdec99d3e242e585e9">OnUserPostNick</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;oldnick)</td></tr>
<tr class="separator:ad35164fe098f2acdec99d3e242e585e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6730818b940e3a53488ac83a7411593f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a6730818b940e3a53488ac83a7411593f">OnPreMode</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, <a class="el" href="class_channel.html">Channel</a> *channel, <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;modes)</td></tr>
<tr class="separator:a6730818b940e3a53488ac83a7411593f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7c84eedaa7cfe94607bf0debbc8244"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4c7c84eedaa7cfe94607bf0debbc8244">On005Numeric</a> (std::map&lt; std::string, std::string &gt; &amp;tokens)</td></tr>
<tr class="separator:a4c7c84eedaa7cfe94607bf0debbc8244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140312a31a1e9163193dd7707707c6b8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a140312a31a1e9163193dd7707707c6b8">OnKill</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, const std::string &amp;reason)</td></tr>
<tr class="separator:a140312a31a1e9163193dd7707707c6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedc27f4e91f68ee71ca14afa91e7145"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#abedc27f4e91f68ee71ca14afa91e7145">OnLoadModule</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="separator:abedc27f4e91f68ee71ca14afa91e7145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55ed63d022db5f011db3d8c03ef6953"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab55ed63d022db5f011db3d8c03ef6953">OnUnloadModule</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="separator:ab55ed63d022db5f011db3d8c03ef6953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22aeb882a4a4cc619ebb7625ae241686"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a22aeb882a4a4cc619ebb7625ae241686">OnBackgroundTimer</a> (time_t curtime)</td></tr>
<tr class="separator:a22aeb882a4a4cc619ebb7625ae241686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4698d4a4a5da9922539459e873bf8d4c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4698d4a4a5da9922539459e873bf8d4c">OnPreCommand</a> (std::string &amp;command, <a class="el" href="class_command_base_1_1_params.html">CommandBase::Params</a> &amp;parameters, <a class="el" href="class_local_user.html">LocalUser</a> *user, bool validated)</td></tr>
<tr class="separator:a4698d4a4a5da9922539459e873bf8d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c2cd321547c9b2f6d32f948ec7afd9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af0c2cd321547c9b2f6d32f948ec7afd9">OnPostCommand</a> (<a class="el" href="class_command.html">Command</a> *command, const <a class="el" href="class_command_base_1_1_params.html">CommandBase::Params</a> &amp;parameters, <a class="el" href="class_local_user.html">LocalUser</a> *user, CmdResult result, bool loop)</td></tr>
<tr class="separator:af0c2cd321547c9b2f6d32f948ec7afd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8edac9bee2f411c2c34fcf9e7f81d40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab8edac9bee2f411c2c34fcf9e7f81d40">OnCommandBlocked</a> (const std::string &amp;command, const <a class="el" href="class_command_base_1_1_params.html">CommandBase::Params</a> &amp;parameters, <a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:ab8edac9bee2f411c2c34fcf9e7f81d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ed68d2c341e59dd9acc50672d67aae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a45ed68d2c341e59dd9acc50672d67aae">OnUserInit</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:a45ed68d2c341e59dd9acc50672d67aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84ccce091b9f93467fae84f18fc9668"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af84ccce091b9f93467fae84f18fc9668">OnUserPostInit</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:af84ccce091b9f93467fae84f18fc9668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05531b903581d8100ca28934eac468d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab05531b903581d8100ca28934eac468d">OnCheckReady</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:ab05531b903581d8100ca28934eac468d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee48e5f4d4efbb826f462c1e5f4d0ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aeee48e5f4d4efbb826f462c1e5f4d0ee">OnUserRegister</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:aeee48e5f4d4efbb826f462c1e5f4d0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6fc87d0e8f6847eee8e216f8026c08"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#afe6fc87d0e8f6847eee8e216f8026c08">OnCheckInvite</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="separator:afe6fc87d0e8f6847eee8e216f8026c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a4f0803a5dfbfc2ea62d8c862f42c9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a44a4f0803a5dfbfc2ea62d8c862f42c9">OnRawMode</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, <a class="el" href="class_mode_handler.html">ModeHandler</a> *mh, const std::string &amp;param, bool adding)</td></tr>
<tr class="separator:a44a4f0803a5dfbfc2ea62d8c862f42c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75601f0642212088ae40e38b186595fd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a75601f0642212088ae40e38b186595fd">OnCheckKey</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;keygiven)</td></tr>
<tr class="separator:a75601f0642212088ae40e38b186595fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63e9aa43689a8bac7bb27c39e430d9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab63e9aa43689a8bac7bb27c39e430d9e">OnCheckLimit</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="separator:ab63e9aa43689a8bac7bb27c39e430d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e86cd99c82307e8c5d19fec3b575d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a54e86cd99c82307e8c5d19fec3b575d2">OnCheckChannelBan</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="separator:a54e86cd99c82307e8c5d19fec3b575d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029982a980048c30c5b4dec12886af76"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a029982a980048c30c5b4dec12886af76">OnCheckBan</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;mask)</td></tr>
<tr class="separator:a029982a980048c30c5b4dec12886af76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329aa3d2f888266d347122df7cdab3bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a329aa3d2f888266d347122df7cdab3bc">OnExtBanCheck</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, char type)</td></tr>
<tr class="separator:a329aa3d2f888266d347122df7cdab3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8028519013eba76b59de3346bd5b0498"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a8028519013eba76b59de3346bd5b0498">OnPreChangeHost</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="separator:a8028519013eba76b59de3346bd5b0498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060080b9ac484e4d16d649b239dced89"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a060080b9ac484e4d16d649b239dced89">OnPreChangeRealName</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="separator:a060080b9ac484e4d16d649b239dced89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0fffc69b3af9695efaec60df2a1876"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aaf0fffc69b3af9695efaec60df2a1876">OnPreTopicChange</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;topic)</td></tr>
<tr class="separator:aaf0fffc69b3af9695efaec60df2a1876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6faca7798ee9ac8a9330c79bacbcd4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a9a6faca7798ee9ac8a9330c79bacbcd4">OnPostTopicChange</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;topic)</td></tr>
<tr class="separator:a9a6faca7798ee9ac8a9330c79bacbcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a40bf5ebb638640047a5089e41c333"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab2a40bf5ebb638640047a5089e41c333">OnPassCompare</a> (<a class="el" href="class_extensible.html">Extensible</a> *ex, const std::string &amp;password, const std::string &amp;input, const std::string &amp;hashtype)</td></tr>
<tr class="separator:ab2a40bf5ebb638640047a5089e41c333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a7c87d002fe32d4d0f46a7f438fbbb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aa3a7c87d002fe32d4d0f46a7f438fbbb">OnPostConnect</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="separator:aa3a7c87d002fe32d4d0f46a7f438fbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947eef29c1aa49f6f935f60bf313ac2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7947eef29c1aa49f6f935f60bf313ac2">OnAcceptConnection</a> (int fd, <a class="el" href="class_listen_socket.html">ListenSocket</a> *sock, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *client, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *server)</td></tr>
<tr class="separator:a7947eef29c1aa49f6f935f60bf313ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152a4ce724c1fed088c51c12be43a62b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a152a4ce724c1fed088c51c12be43a62b">OnGarbageCollect</a> ()</td></tr>
<tr class="separator:a152a4ce724c1fed088c51c12be43a62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7c6fc1a66af63568b6a69db294a0df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5a7c6fc1a66af63568b6a69db294a0df">OnSetConnectClass</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, <a class="el" href="class_connect_class.html">ConnectClass</a> *myclass)</td></tr>
<tr class="separator:a5a7c6fc1a66af63568b6a69db294a0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bafaf65ad8df653a2754e5452ec04a"><td class="memItemLeft" align="right" valign="top"><a id="a63bafaf65ad8df653a2754e5452ec04a"></a>
virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OnNumeric</b> (<a class="el" href="class_user.html">User</a> *user, const <a class="el" href="class_numeric_1_1_numeric.html">Numeric::Numeric</a> &amp;numeric)</td></tr>
<tr class="separator:a63bafaf65ad8df653a2754e5452ec04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9edd94c35056b40d076acf56c6afa0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a3d9edd94c35056b40d076acf56c6afa0">OnSetUserIP</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:a3d9edd94c35056b40d076acf56c6afa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740d7f295d67d93c40dc4c699c9f9abc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a740d7f295d67d93c40dc4c699c9f9abc">OnServiceAdd</a> (<a class="el" href="class_service_provider.html">ServiceProvider</a> &amp;service)</td></tr>
<tr class="separator:a740d7f295d67d93c40dc4c699c9f9abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bf42c45356dc85ae0fe07280acb6ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af5bf42c45356dc85ae0fe07280acb6ba">OnServiceDel</a> (<a class="el" href="class_service_provider.html">ServiceProvider</a> &amp;service)</td></tr>
<tr class="separator:af5bf42c45356dc85ae0fe07280acb6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadd96f81a5cf5af438162f2b9a0c1f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#abadd96f81a5cf5af438162f2b9a0c1f1">OnUserWrite</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, <a class="el" href="class_client_protocol_1_1_message.html">ClientProtocol::Message</a> &amp;msg)</td></tr>
<tr class="separator:abadd96f81a5cf5af438162f2b9a0c1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4bcd40ef6f80cb983ea01747864355"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a8a4bcd40ef6f80cb983ea01747864355">OnConnectionFail</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, BufferedSocketError error)</td></tr>
<tr class="separator:a8a4bcd40ef6f80cb983ea01747864355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac4639fe1a9f3723ae8350b459b641b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#adac4639fe1a9f3723ae8350b459b641b">OnShutdown</a> (const std::string &amp;reason)</td></tr>
<tr class="separator:adac4639fe1a9f3723ae8350b459b641b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classusecountbase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classusecountbase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classusecountbase.html">usecountbase</a></td></tr>
<tr class="memitem:a0f617fa3620bd5dd98d56177b38b27a1 inherit pub_methods_classusecountbase"><td class="memItemLeft" align="right" valign="top"><a id="a0f617fa3620bd5dd98d56177b38b27a1"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>GetUseCount</b> () const</td></tr>
<tr class="separator:a0f617fa3620bd5dd98d56177b38b27a1 inherit pub_methods_classusecountbase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125c71f3f86f02308069779d56ba19de inherit pub_methods_classusecountbase"><td class="memItemLeft" align="right" valign="top"><a id="a125c71f3f86f02308069779d56ba19de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>refcount_inc</b> () const</td></tr>
<tr class="separator:a125c71f3f86f02308069779d56ba19de inherit pub_methods_classusecountbase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dff7f913ddd36ff25cd66793e6da78 inherit pub_methods_classusecountbase"><td class="memItemLeft" align="right" valign="top"><a id="a29dff7f913ddd36ff25cd66793e6da78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>refcount_dec</b> () const</td></tr>
<tr class="separator:a29dff7f913ddd36ff25cd66793e6da78 inherit pub_methods_classusecountbase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4b9d41041b7b56a786064020e9c50c75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4b9d41041b7b56a786064020e9c50c75">ModuleSourceFile</a></td></tr>
<tr class="separator:a4b9d41041b7b56a786064020e9c50c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbdc3c59248520549e5904bb402e2cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_l_l_manager.html">DLLManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5bbdc3c59248520549e5904bb402e2cb">ModuleDLLManager</a></td></tr>
<tr class="separator:a5bbdc3c59248520549e5904bb402e2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab94177da81fe7a68f37e48a554e272f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aab94177da81fe7a68f37e48a554e272f">dying</a></td></tr>
<tr class="separator:aab94177da81fe7a68f37e48a554e272f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for all <a class="el" href="class_insp_i_r_cd.html">InspIRCd</a> modules This class is the base class for <a class="el" href="class_insp_i_r_cd.html">InspIRCd</a> modules. All modules must inherit from this class, its methods will be called when irc server events occur. class inherited from module must be instantiated by the ModuleFactory class (see relevant section) for the module to be initialised. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a83b2c5b16047bc1a89ab9035396fbdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b2c5b16047bc1a89ab9035396fbdd6">&#9670;&nbsp;</a></span>List</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_module.html">Module</a>*&gt; <a class="el" href="class_module.html#a83b2c5b16047bc1a89ab9035396fbdd6">Module::List</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A list of modules. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5a240a8a9ab1813b17bcb810b24ceaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a240a8a9ab1813b17bcb810b24ceaea">&#9670;&nbsp;</a></span>Module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Module::Module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Creates a module class. Don't do any type of hook registration or checks for other modules here; do that in <a class="el" href="class_module.html#ab19e59816d97db07363143c859ad0c10">init()</a>. </p>

</div>
</div>
<a id="a7c9d9c096786d127590fdd8aa2b7d681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9d9c096786d127590fdd8aa2b7d681">&#9670;&nbsp;</a></span>~Module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Module::~Module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default destructor. destroys a module class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9cf4e278594597a19264689a2d14bde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf4e278594597a19264689a2d14bde0">&#9670;&nbsp;</a></span>cull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cull_result.html">CullResult</a> Module::cull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clean up prior to destruction If you override, you must call this AFTER your module's cleanup </p>

<p>Reimplemented from <a class="el" href="classclassbase.html#a2a773ec2f42d047e0ce250553f44d831">classbase</a>.</p>

</div>
</div>
<a id="ace1cba59ac54d26b4649858b2cfc6aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1cba59ac54d26b4649858b2cfc6aa8">&#9670;&nbsp;</a></span>GetVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_version.html">Version</a> Module::GetVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the version number of a <a class="el" href="class_module.html">Module</a>. The method should return a <a class="el" href="class_version.html">Version</a> object with its version information assigned via <a class="el" href="class_version.html#aaf3a196a2f6e05adc2dfb92844adcf73">Version::Version</a> </p>

</div>
</div>
<a id="ab19e59816d97db07363143c859ad0c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19e59816d97db07363143c859ad0c10">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Module::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_module.html">Module</a> setup </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_module_exception.html">ModuleException</a></td><td>Throwing this class, or any class derived from <a class="el" href="class_module_exception.html">ModuleException</a>, causes loading of the module to abort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c7c84eedaa7cfe94607bf0debbc8244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7c84eedaa7cfe94607bf0debbc8244">&#9670;&nbsp;</a></span>On005Numeric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::On005Numeric </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>tokens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a 005 numeric is about to be output. The module should modify the 005 numeric if needed to indicate its features. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tokens</td><td>The 005 map to be modified if necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7947eef29c1aa49f6f935f60bf313ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947eef29c1aa49f6f935f60bf313ac2">&#9670;&nbsp;</a></span>OnAcceptConnection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnAcceptConnection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_listen_socket.html">ListenSocket</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *&#160;</td>
          <td class="paramname"><em>server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a port accepts a connection Return MOD_RES_ACCEPT if you have used the file descriptor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor returned from accept() </td></tr>
    <tr><td class="paramname">sock</td><td>The socket connection for the new user </td></tr>
    <tr><td class="paramname">client</td><td>The client IP address and port </td></tr>
    <tr><td class="paramname">server</td><td>The server IP address and port </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace17c45466526ac93a24c8a7441b59e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace17c45466526ac93a24c8a7441b59e3">&#9670;&nbsp;</a></span>OnAddLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnAddLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_line.html">XLine</a> *&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever an xline is added by a local user. This method is triggered after the line is added. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The sender of the line or NULL for local server </td></tr>
    <tr><td class="paramname">line</td><td>The xline being added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22aeb882a4a4cc619ebb7625ae241686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22aeb882a4a4cc619ebb7625ae241686">&#9670;&nbsp;</a></span>OnBackgroundTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnBackgroundTimer </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>curtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called once every five seconds for background processing. This timer can be used to control timed features. Its period is not accurate enough to be used as a clock, but it is guaranteed to be called at least once in any five second period, directly from the main loop of the server. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curtime</td><td>The current timer derived from time(2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2c2e173e33c6e288fea2ddc494d7edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c2e173e33c6e288fea2ddc494d7edd">&#9670;&nbsp;</a></span>OnBuildNeighborList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnBuildNeighborList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncludeChanList &amp;&#160;</td>
          <td class="paramname"><em>include_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_user.html">User</a> *, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>exceptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when sending a message to all "neighbors" of a given user - that is, all users that share a common channel. This is used in commands such as NICK, QUIT, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source of the message </td></tr>
    <tr><td class="paramname">include_c</td><td>Channels to scan for users to include </td></tr>
    <tr><td class="paramname">exceptions</td><td>Map of user-&gt;bool that overrides the inclusion decision</td></tr>
  </table>
  </dd>
</dl>
<p>Set exceptions[user] = true to include, exceptions[user] = false to exclude </p>

</div>
</div>
<a id="a9f6aa4ebe19c22eb32f7a65ecbc74594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6aa4ebe19c22eb32f7a65ecbc74594">&#9670;&nbsp;</a></span>OnChangeHost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnChangeHost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's hostname is changed. This event triggers after the host has been set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whose host is being changed </td></tr>
    <tr><td class="paramname">newhost</td><td>The new hostname being set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a135ab5a74a236dc4f696191b25efec2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135ab5a74a236dc4f696191b25efec2b">&#9670;&nbsp;</a></span>OnChangeIdent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnChangeIdent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ident</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's IDENT is changed. This event triggers after the name has been set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who's IDENT is being changed </td></tr>
    <tr><td class="paramname">ident</td><td>The new IDENT being set on the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab863fadc8f2f0c7f2968ac8292d27cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab863fadc8f2f0c7f2968ac8292d27cd">&#9670;&nbsp;</a></span>OnChangeRealHost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnChangeRealHost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's real hostname is changed. This event triggers before the host has been set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whose host is being changed </td></tr>
    <tr><td class="paramname">newhost</td><td>The new hostname being set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e9cee26dfdf58c5e001fafedbefc107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9cee26dfdf58c5e001fafedbefc107">&#9670;&nbsp;</a></span>OnChangeRealName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnChangeRealName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>real</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's real name is changed. This event triggers after the name has been set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who's real name is being changed </td></tr>
    <tr><td class="paramname">real</td><td>The new real name being set on the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c6be01493bcae74002a9e81d3ba3473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6be01493bcae74002a9e81d3ba3473">&#9670;&nbsp;</a></span>OnChannelDelete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnChannelDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a channel is deleted, either by QUIT, KICK or PART. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>The channel being deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90f0a0386640538a817ab4b461d75dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f0a0386640538a817ab4b461d75dba">&#9670;&nbsp;</a></span>OnChannelPreDelete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnChannelPreDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a channel is about to be deleted </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>The channel being deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer specifying whether or not the channel may be deleted. 0 for yes, 1 for no. </dd></dl>

</div>
</div>
<a id="a029982a980048c30c5b4dec12886af76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029982a980048c30c5b4dec12886af76">&#9670;&nbsp;</a></span>OnCheckBan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnCheckBan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks for a user's match of a single ban </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user to check for match </td></tr>
    <tr><td class="paramname">chan</td><td>The channel on which the match is being checked </td></tr>
    <tr><td class="paramname">mask</td><td>The mask being checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MOD_RES_DENY to mark as banned, MOD_RES_ALLOW to skip the ban check, or MOD_RES_PASSTHRU to check bans normally </dd></dl>

</div>
</div>
<a id="a54e86cd99c82307e8c5d19fec3b575d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e86cd99c82307e8c5d19fec3b575d2">&#9670;&nbsp;</a></span>OnCheckChannelBan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnCheckChannelBan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks for a user's ban from the channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user to check </td></tr>
    <tr><td class="paramname">chan</td><td>The channel to check in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MOD_RES_DENY to mark as banned, MOD_RES_ALLOW to skip the ban check, or MOD_RES_PASSTHRU to check bans normally </dd></dl>

</div>
</div>
<a id="afe6fc87d0e8f6847eee8e216f8026c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6fc87d0e8f6847eee8e216f8026c08">&#9670;&nbsp;</a></span>OnCheckInvite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnCheckInvite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user joins a channel, to determine if invite checks should go ahead or not. This method will always be called for each join, whether or not the channel is actually +i, and determines the outcome of an if statement around the whole section of invite checking code. return 1 to explicitly allow the join to go ahead or 0 to ignore the event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user joining the channel </td></tr>
    <tr><td class="paramname">chan</td><td>The channel being joined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to explicitly allow the join, 0 to proceed as normal </dd></dl>

</div>
</div>
<a id="a75601f0642212088ae40e38b186595fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75601f0642212088ae40e38b186595fd">&#9670;&nbsp;</a></span>OnCheckKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnCheckKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keygiven</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user joins a channel, to determine if key checks should go ahead or not. This method will always be called for each join, whether or not the channel is actually +k, and determines the outcome of an if statement around the whole section of key checking code. if the user specified no key, the keygiven string will be a valid but empty value. return 1 to explicitly allow the join to go ahead or 0 to ignore the event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user joining the channel </td></tr>
    <tr><td class="paramname">chan</td><td>The channel being joined </td></tr>
    <tr><td class="paramname">keygiven</td><td>The key given on joining the channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to explicitly allow the join, 0 to proceed as normal </dd></dl>

</div>
</div>
<a id="ab63e9aa43689a8bac7bb27c39e430d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63e9aa43689a8bac7bb27c39e430d9e">&#9670;&nbsp;</a></span>OnCheckLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnCheckLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user joins a channel, to determine if channel limit checks should go ahead or not. This method will always be called for each join, whether or not the channel is actually +l, and determines the outcome of an if statement around the whole section of channel limit checking code. return 1 to explicitly allow the join to go ahead or 0 to ignore the event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user joining the channel </td></tr>
    <tr><td class="paramname">chan</td><td>The channel being joined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to explicitly allow the join, 0 to proceed as normal </dd></dl>

</div>
</div>
<a id="ab05531b903581d8100ca28934eac468d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05531b903581d8100ca28934eac468d">&#9670;&nbsp;</a></span>OnCheckReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnCheckReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called to check if a user who is connecting can now be allowed to register If any modules return false for this function, the user is held in the waiting state until all modules return true. For example a module which implements ident lookups will continue to return false for a user until their ident lookup is completed. Note that the registration timeout for a user overrides these checks, if the registration timeout is reached, the user is disconnected even if modules report that the user is not ready to connect. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true to indicate readiness, false if otherwise </dd></dl>

</div>
</div>
<a id="ace3323630e669476ed433b36b6863618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3323630e669476ed433b36b6863618">&#9670;&nbsp;</a></span>OnCleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnCleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_extension_item.html#a033cb646471c0d59024f927bcc34a34b">ExtensionItem::ExtensibleType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_extensible.html">Extensible</a> *&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before the module is unloaded to clean up extensibles. This method is called once for every channel, membership, and user. so that you can clear up any data relating to the specified extensible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of extensible being cleaned up. If this is EXT_CHANNEL then item is a Channel*, EXT_MEMBERSHIP then item is a Membership*, and EXT_USER then item is a User*. </td></tr>
    <tr><td class="paramname">item</td><td>A pointer to the extensible which is being cleaned up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8edac9bee2f411c2c34fcf9e7f81d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8edac9bee2f411c2c34fcf9e7f81d40">&#9670;&nbsp;</a></span>OnCommandBlocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnCommandBlocked </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_command_base_1_1_params.html">CommandBase::Params</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a command was blocked before it could be executed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command being executed. </td></tr>
    <tr><td class="paramname">parameters</td><td>The parameters for the command. </td></tr>
    <tr><td class="paramname">user</td><td>The user issuing the command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a4bcd40ef6f80cb983ea01747864355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4bcd40ef6f80cb983ea01747864355">&#9670;&nbsp;</a></span>OnConnectionFail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnConnectionFail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferedSocketError&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user connection has been unexpectedly disconnected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who has been unexpectedly disconnected. </td></tr>
    <tr><td class="paramname">error</td><td>The type of error which caused this connection failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MOD_RES_ALLOW to explicitly retain the user as a zombie, MOD_RES_DENY to explicitly disconnect the user, or MOD_RES_PASSTHRU to let another module handle the event. </dd></dl>

</div>
</div>
<a id="af2e2a4e731ead980507fd02e0b1f69b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e2a4e731ead980507fd02e0b1f69b0">&#9670;&nbsp;</a></span>OnDecodeMetaData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnDecodeMetaData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_extensible.html">Extensible</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows module data, sent via ProtoSendMetaData, to be decoded again by a receiving module. Please see src/modules/m_swhois.cpp for a working example of how to use this method call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The Channel* or User* that data should be added to </td></tr>
    <tr><td class="paramname">extname</td><td>The extension name which is being sent </td></tr>
    <tr><td class="paramname">extdata</td><td>The extension data, encoded at the other end by an identical module </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa784e9b35582872ca8228053c93615d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa784e9b35582872ca8228053c93615d7">&#9670;&nbsp;</a></span>OnDelLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnDelLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_line.html">XLine</a> *&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever an xline is deleted MANUALLY. See OnExpireLine for expiry. This method is triggered after the line is deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user removing the line or NULL for local server </td></tr>
    <tr><td class="paramname">line</td><td>the line being deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33b8a6dd1c8e6f2e8e15eed14a5205e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b8a6dd1c8e6f2e8e15eed14a5205e6">&#9670;&nbsp;</a></span>OnExpireLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnExpireLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_x_line.html">XLine</a> *&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever an xline expires. This method is triggered after the line is deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line being deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a329aa3d2f888266d347122df7cdab3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329aa3d2f888266d347122df7cdab3bc">&#9670;&nbsp;</a></span>OnExtBanCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnExtBanCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks for a match on a given extban type </p><dl class="section return"><dt>Returns</dt><dd>MOD_RES_DENY to mark as banned, MOD_RES_ALLOW to skip the ban check, or MOD_RES_PASSTHRU to check bans normally </dd></dl>

</div>
</div>
<a id="a152a4ce724c1fed088c51c12be43a62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152a4ce724c1fed088c51c12be43a62b">&#9670;&nbsp;</a></span>OnGarbageCollect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnGarbageCollect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called at intervals for modules to garbage-collect any hashes etc. Certain data types such as hash_map 'leak' buckets, which must be tidied up and freed by copying into a new item every so often. This method is called when it is time to do that. </p>

</div>
</div>
<a id="a140312a31a1e9163193dd7707707c6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140312a31a1e9163193dd7707707c6b8">&#9670;&nbsp;</a></span>OnKill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnKill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a client is disconnected by KILL. If a client is killed by a server, e.g. a nickname collision or protocol error, source is NULL. Return 1 from this function to prevent the kill, and 0 from this function to allow it as normal. If you prevent the kill no output will be sent to the client, it is down to your module to generate this information. NOTE: It is NOT advisable to stop kills which originate from servers or remote users. If you do so youre risking race conditions, desyncs and worse! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user sending the KILL </td></tr>
    <tr><td class="paramname">dest</td><td>The user being killed </td></tr>
    <tr><td class="paramname">reason</td><td>The kill reason </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to prevent the kill, 0 to allow </dd></dl>

</div>
</div>
<a id="abedc27f4e91f68ee71ca14afa91e7145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abedc27f4e91f68ee71ca14afa91e7145">&#9670;&nbsp;</a></span>OnLoadModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnLoadModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a module is loaded. mod will contain a pointer to the module, and string will contain its name, for example m_widgets.so. This function is primary for dependency checking, your module may decide to enable some extra features if it sees that you have for example loaded "m_killwidgets.so" with "m_makewidgets.so". It is highly recommended that modules do <em>NOT</em> bail if they cannot satisfy dependencies, but instead operate under reduced functionality, unless the dependency is absolutely necessary (e.g. a module that extends the features of another module). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>A pointer to the new module </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaa2dac1cd107a0f20f64459b24e9ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa2dac1cd107a0f20f64459b24e9ad7">&#9670;&nbsp;</a></span>OnMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>usertarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chantarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>changelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModeParser::ModeProcessFlag&#160;</td>
          <td class="paramname"><em>processflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after every MODE command sent from a user Either the usertarget or the chantarget variable contains the target of the modes, the actual target will have a non-NULL pointer. All changed modes are available in the changelist object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the MODEs </td></tr>
    <tr><td class="paramname">usertarget</td><td>The target user of the modes, NULL if the target is a channel </td></tr>
    <tr><td class="paramname">chantarget</td><td>The target channel of the modes, NULL if the target is a user </td></tr>
    <tr><td class="paramname">changelist</td><td>The changed modes. </td></tr>
    <tr><td class="paramname">processflags</td><td>Flags passed to <a class="el" href="class_mode_parser.html#a75a5dd40880fc77347686e13bac933dc">ModeParser::Process()</a>, see <a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588b">ModeParser::ModeProcessFlags</a> for the possible flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaae6d16d1fe5d629dce9deedaa0a1b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae6d16d1fe5d629dce9deedaa0a1b49">&#9670;&nbsp;</a></span>OnModuleRehash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnModuleRehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called on rehash. This method is called when a user initiates a module-specific rehash. This can be used to do expensive operations (such as reloading TLS (SSL) certificates) that are not executed on a normal rehash for efficiency. A rehash of this type does not reload the core configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user performing the rehash. </td></tr>
    <tr><td class="paramname">parameter</td><td>The parameter given to REHASH </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb6f7ea0790f23d6c15ff3daf40b7f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6f7ea0790f23d6c15ff3daf40b7f48">&#9670;&nbsp;</a></span>OnOper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnOper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opertype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user opers locally. The <a class="el" href="class_user.html">User</a> will contain the oper mode 'o' as this function is called after any modifications are made to the user's structure by the core. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is opering up </td></tr>
    <tr><td class="paramname">opertype</td><td>The opers type name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2a40bf5ebb638640047a5089e41c333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a40bf5ebb638640047a5089e41c333">&#9670;&nbsp;</a></span>OnPassCompare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnPassCompare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_extensible.html">Extensible</a> *&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hashtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a password check is to be made. Replaces the old OldOperCompare API. The password field (from the config file) is in 'password' and is to be compared against 'input'. This method allows for encryption of passwords (oper, connect:allow, die/restart, etc). You should return a nonzero value to override the normal comparison, or zero to pass it on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The object that's causing the authentication (User* for &lt;oper&gt; &lt;connect:allow&gt; etc, Server* for &lt;link&gt;). </td></tr>
    <tr><td class="paramname">password</td><td>The password from the configuration file (the password="" value). </td></tr>
    <tr><td class="paramname">input</td><td>The password entered by the user or whoever. </td></tr>
    <tr><td class="paramname">hashtype</td><td>The hash value from the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 to do nothing (pass on to next module/default), 1 == password is OK, -1 == password is not OK </dd></dl>

</div>
</div>
<a id="a1b29d59fa658b5d8ccef313270b8cf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b29d59fa658b5d8ccef313270b8cf37">&#9670;&nbsp;</a></span>OnPostChangeRealHost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostChangeRealHost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's real hostname is changed. This event triggers after the host has been set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whos host was changed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0c2cd321547c9b2f6d32f948ec7afd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c2cd321547c9b2f6d32f948ec7afd9">&#9670;&nbsp;</a></span>OnPostCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command.html">Command</a> *&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_command_base_1_1_params.html">CommandBase::Params</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmdResult&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after any command has been executed. This event occurs for all registered commands, whether they are registered in the core, or another module, but it will not occur for invalid commands (e.g. ones which do not exist within the command table). The result code returned by the command handler is provided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command being executed </td></tr>
    <tr><td class="paramname">parameters</td><td>An array of array of characters containing the parameters for the command </td></tr>
    <tr><td class="paramname">user</td><td>the user issuing the command </td></tr>
    <tr><td class="paramname">result</td><td>The return code given by the command handler, one of CMD_SUCCESS or CMD_FAILURE </td></tr>
    <tr><td class="paramname">loop</td><td>Whether the command is being called from LoopCall or directly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3a7c87d002fe32d4d0f46a7f438fbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a7c87d002fe32d4d0f46a7f438fbbb">&#9670;&nbsp;</a></span>OnPostConnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user has fully connected and all modules have executed OnUserConnect This event is informational only. You should not change any user information in this event. To do so, use the OnUserConnect method to change the state of local users. This is called for both local and remote users. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is connecting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3ce87b25ff0b4ad30f2dc8fed36a2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ce87b25ff0b4ad30f2dc8fed36a2c7">&#9670;&nbsp;</a></span>OnPostDeoper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostDeoper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user deopers locally. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who has deopered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3be3a9518b0ee13a391ae6daffa5553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3be3a9518b0ee13a391ae6daffa5553">&#9670;&nbsp;</a></span>OnPostJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user joins a channel Identical to OnUserJoin, but called immediately afterwards, when any linking module has seen the join. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memb</td><td>The channel membership created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0b2ffd9df24552ff78888a536faceba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b2ffd9df24552ff78888a536faceba">&#9670;&nbsp;</a></span>OnPostOper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostOper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opername</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opertype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user opers locally. This is identical to <a class="el" href="class_module.html#afb6f7ea0790f23d6c15ff3daf40b7f48">Module::OnOper()</a>, except it is called after OnOper so that other modules can be guaranteed to already have processed the oper-up, for example m_spanningtree has sent out the OPERTYPE, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is opering up </td></tr>
    <tr><td class="paramname">opername</td><td>The name of the oper that the user is opering up to. Only valid locally. Empty string otherwise. </td></tr>
    <tr><td class="paramname">opertype</td><td>The opers type name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a6faca7798ee9ac8a9330c79bacbcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6faca7798ee9ac8a9330c79bacbcd4">&#9670;&nbsp;</a></span>OnPostTopicChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostTopicChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a topic has been changed. To block topic changes you must use OnPreTopicChange instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user changing the topic </td></tr>
    <tr><td class="paramname">chan</td><td>The channels who's topic is being changed </td></tr>
    <tr><td class="paramname">topic</td><td>The actual topic text </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8028519013eba76b59de3346bd5b0498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8028519013eba76b59de3346bd5b0498">&#9670;&nbsp;</a></span>OnPreChangeHost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnPreChangeHost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a change of a local users displayed host is attempted. Return 1 to deny the host change, or 0 to allow it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whose host will be changed </td></tr>
    <tr><td class="paramname">newhost</td><td>The new hostname </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to deny the host change, 0 to allow </dd></dl>

</div>
</div>
<a id="a060080b9ac484e4d16d649b239dced89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060080b9ac484e4d16d649b239dced89">&#9670;&nbsp;</a></span>OnPreChangeRealName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnPreChangeRealName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a change of a local users real name is attempted. return MOD_RES_DENY to deny the name change, or MOD_RES_ALLOW to allow it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whose real name will be changed </td></tr>
    <tr><td class="paramname">newhost</td><td>The new real name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MOD_RES_DENY to deny the real name change, MOD_RES_ALLOW to allow </dd></dl>

</div>
</div>
<a id="a4698d4a4a5da9922539459e873bf8d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4698d4a4a5da9922539459e873bf8d4c">&#9670;&nbsp;</a></span>OnPreCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnPreCommand </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_command_base_1_1_params.html">CommandBase::Params</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever any command is about to be executed. This event occurs for all registered commands, whether they are registered in the core, or another module, and for invalid commands. Invalid commands may only be sent to this function when the value of validated is false. By returning 1 from this method you may prevent the command being executed. If you do this, no output is created by the core, and it is down to your module to produce any output necessary. Note that unless you return 1, you should not destroy any structures (e.g. by using InspIRCd::QuitUser) otherwise when the command's handler function executes after your method returns, it will be passed an invalid pointer to the user object and crash!) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command being executed </td></tr>
    <tr><td class="paramname">parameters</td><td>An array of array of characters containing the parameters for the command </td></tr>
    <tr><td class="paramname">user</td><td>the user issuing the command </td></tr>
    <tr><td class="paramname">validated</td><td>True if the command has passed all checks, e.g. it is recognised, has enough parameters, the user has permission to execute it, etc. You should only change the parameter list and command string if validated == false (e.g. before the command lookup occurs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to block the command, 0 to allow </dd></dl>

</div>
</div>
<a id="a6730818b940e3a53488ac83a7411593f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6730818b940e3a53488ac83a7411593f">&#9670;&nbsp;</a></span>OnPreMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnPreMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before a mode change via the MODE command, to allow a single access check for a full mode change (use OnRawMode to check individual modes)</p>
<p>Returning MOD_RES_ALLOW will skip prefix level checks, but can be overridden by OnRawMode for each individual mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the user making the mode change </td></tr>
    <tr><td class="paramname">dest</td><td>the user destination of the umode change (NULL if a channel mode) </td></tr>
    <tr><td class="paramname">channel</td><td>the channel destination of the mode change </td></tr>
    <tr><td class="paramname">modes</td><td>Modes being changed, can be edited </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a390969a3664c10646dfe13be95ac016d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390969a3664c10646dfe13be95ac016d">&#9670;&nbsp;</a></span>OnPreRehash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPreRehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called on rehash. This method is called prior to a /REHASH or when a SIGHUP is received from the operating system. This is called in all cases &ndash; including when this server will not execute the rehash because it is directed at a remote server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user performing the rehash, if any. If this is server initiated, the value of this variable will be NULL. </td></tr>
    <tr><td class="paramname">parameter</td><td>The (optional) parameter given to REHASH from the user. Empty when server initiated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf0fffc69b3af9695efaec60df2a1876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0fffc69b3af9695efaec60df2a1876">&#9670;&nbsp;</a></span>OnPreTopicChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnPreTopicChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before a topic is changed. Return 1 to deny the topic change, 0 to check details on the change, -1 to let it through with no checks As with other 'pre' events, you should only ever block a local event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user changing the topic </td></tr>
    <tr><td class="paramname">chan</td><td>The channels who's topic is being changed </td></tr>
    <tr><td class="paramname">topic</td><td>The actual topic text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to block the topic change, 0 to allow </dd></dl>

</div>
</div>
<a id="a44a4f0803a5dfbfc2ea62d8c862f42c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a4f0803a5dfbfc2ea62d8c862f42c9">&#9670;&nbsp;</a></span>OnRawMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnRawMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mode_handler.html">ModeHandler</a> *&#160;</td>
          <td class="paramname"><em>mh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a mode character is processed. Return 1 from this function to block the mode character from being processed entirely. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is sending the mode </td></tr>
    <tr><td class="paramname">chan</td><td>The channel the mode is being sent to (or NULL if a usermode) </td></tr>
    <tr><td class="paramname">mh</td><td>The mode handler for the mode being changed </td></tr>
    <tr><td class="paramname">param</td><td>The parameter for the mode or an empty string </td></tr>
    <tr><td class="paramname">adding</td><td>true of the mode is being added, false if it is being removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACR_DENY to deny the mode, ACR_DEFAULT to do standard mode checking, and ACR_ALLOW to skip all permission checking. Please note that for remote mode changes, your return value will be ignored! </dd></dl>

</div>
</div>
<a id="a7d39c9fabab9dea701f4a3ad2cfff37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d39c9fabab9dea701f4a3ad2cfff37b">&#9670;&nbsp;</a></span>OnSendSnotice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnSendSnotice </td>
          <td>(</td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>snomask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a snotice is about to be sent to a snomask. snomask and type may both be modified; the message may not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snomask</td><td>The snomask the message is going to (e.g. 'A') </td></tr>
    <tr><td class="paramname">type</td><td>The textual description the snomask will go to (e.g. 'OPER') </td></tr>
    <tr><td class="paramname">message</td><td>The text message to be sent via snotice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to block the snotice from being sent entirely, 0 else. </dd></dl>

</div>
</div>
<a id="a740d7f295d67d93c40dc4c699c9f9abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740d7f295d67d93c40dc4c699c9f9abc">&#9670;&nbsp;</a></span>OnServiceAdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnServiceAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_service_provider.html">ServiceProvider</a> &amp;&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a <a class="el" href="class_service_provider.html">ServiceProvider</a> is registered. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td><a class="el" href="class_service_provider.html">ServiceProvider</a> being registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5bf42c45356dc85ae0fe07280acb6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bf42c45356dc85ae0fe07280acb6ba">&#9670;&nbsp;</a></span>OnServiceDel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnServiceDel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_service_provider.html">ServiceProvider</a> &amp;&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a <a class="el" href="class_service_provider.html">ServiceProvider</a> is unregistered. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td><a class="el" href="class_service_provider.html">ServiceProvider</a> being unregistered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a7c6fc1a66af63568b6a69db294a0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7c6fc1a66af63568b6a69db294a0df">&#9670;&nbsp;</a></span>OnSetConnectClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnSetConnectClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_connect_class.html">ConnectClass</a> *&#160;</td>
          <td class="paramname"><em>myclass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user's connect class is being matched </p><dl class="section return"><dt>Returns</dt><dd>MOD_RES_ALLOW to force the class to match, MOD_RES_DENY to forbid it, or MOD_RES_PASSTHRU to allow normal matching (by host/port). </dd></dl>

</div>
</div>
<a id="a3d9edd94c35056b40d076acf56c6afa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9edd94c35056b40d076acf56c6afa0">&#9670;&nbsp;</a></span>OnSetUserIP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnSetUserIP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a local user's IP is set for the first time, or when a local user's IP changes due to a module like m_cgiirc changing it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whose IP is being set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adac4639fe1a9f3723ae8350b459b641b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac4639fe1a9f3723ae8350b459b641b">&#9670;&nbsp;</a></span>OnShutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnShutdown </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before a server shuts down. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>The reason the server is shutting down. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab55ed63d022db5f011db3d8c03ef6953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55ed63d022db5f011db3d8c03ef6953">&#9670;&nbsp;</a></span>OnUnloadModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUnloadModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a module is unloaded. mod will contain a pointer to the module, and string will contain its name, for example m_widgets.so. This function is primary for dependency checking, your module may decide to enable some extra features if it sees that you have for example loaded "m_killwidgets.so" with "m_makewidgets.so". It is highly recommended that modules do <em>NOT</em> bail if they cannot satisfy dependencies, but instead operate under reduced functionality, unless the dependency is absolutely necessary (e.g. a module that extends the features of another module). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Pointer to the module being unloaded (still valid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3910edd1a48dfe4db141b04157627a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3910edd1a48dfe4db141b04157627a8e">&#9670;&nbsp;</a></span>OnUserConnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user connects. The details of the connecting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is connecting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a193075c27aee23eb8baf613ed31327b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193075c27aee23eb8baf613ed31327b4">&#9670;&nbsp;</a></span>OnUserDisconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserDisconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's socket is closed. The details of the exiting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user This event is called for all users, registered or not, as a cleanup method for modules which might assign resources to user, such as dns lookups, objects and sockets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is disconnecting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ed68d2c341e59dd9acc50672d67aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ed68d2c341e59dd9acc50672d67aae">&#9670;&nbsp;</a></span>OnUserInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user object is initialised and added to the user list. When this is called the user has not had their I/O hooks checked or had their initial connect class assigned and may not yet have a serializer. You probably want to use the OnUserPostInit or OnUserSetIP hooks instead of this one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The connecting user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b0a70a70ae92b80bc3fc7367e35605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b0a70a70ae92b80bc3fc7367e35605">&#9670;&nbsp;</a></span>OnUserInvite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserInvite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>notifyrank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>notifyexcepts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user has been successfully invited to a channel. You cannot prevent the invite from occurring using this function, to do that, use OnUserPreInvite instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user who is issuing the INVITE </td></tr>
    <tr><td class="paramname">dest</td><td>The user being invited </td></tr>
    <tr><td class="paramname">channel</td><td>The channel the user is being invited to </td></tr>
    <tr><td class="paramname">timeout</td><td>The time the invite will expire (0 == never) </td></tr>
    <tr><td class="paramname">notifyrank</td><td>Rank required to get an invite announcement (if enabled) </td></tr>
    <tr><td class="paramname">notifyexcepts</td><td>List of users to not send the default NOTICE invite announcement to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4e65c3401aff9a6c68e2b2f9f2de5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e65c3401aff9a6c68e2b2f9f2de5dd">&#9670;&nbsp;</a></span>OnUserJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>created</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user joins a channel. The details of the joining user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user, and the details of the channel they have joined is available in the variable <a class="el" href="class_channel.html">Channel</a> *channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memb</td><td>The channel membership being created </td></tr>
    <tr><td class="paramname">sync</td><td>This is set to true if the JOIN is the result of a network sync and the remote user is being introduced to a channel due to the network sync. </td></tr>
    <tr><td class="paramname">created</td><td>This is true if the join created the channel </td></tr>
    <tr><td class="paramname">except_list</td><td>A list of users not to send to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a0c7ca18eadf768e69894f2995b0db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0c7ca18eadf768e69894f2995b0db7">&#9670;&nbsp;</a></span>OnUserKick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserKick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is kicked. If this method is called, the kick is already underway and cannot be prevented, so to prevent a kick, please use <a class="el" href="class_module.html#a54fb5e86ea38f35095af102f40894c1b">Module::OnUserPreKick</a> instead of this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user issuing the kick </td></tr>
    <tr><td class="paramname">memb</td><td>The channel membership of the user who was kicked. </td></tr>
    <tr><td class="paramname">reason</td><td>The kick reason </td></tr>
    <tr><td class="paramname">except_list</td><td>A list of users to not send to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac211481d14d51c64485052ccb1b4b28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac211481d14d51c64485052ccb1b4b28c">&#9670;&nbsp;</a></span>OnUserMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_message_target.html">MessageTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_message_details.html">MessageDetails</a> &amp;&#160;</td>
          <td class="paramname"><em>details</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called immediately before a user sends a message to a channel, a user, or a server glob mask. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the message. This can either be a channel, a user, or a server glob mask. </td></tr>
    <tr><td class="paramname">details</td><td>Details about the message such as the message text and type. See the <a class="el" href="class_message_details.html">MessageDetails</a> class for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace99c0beace10bab228c70941e3ead2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace99c0beace10bab228c70941e3ead2b">&#9670;&nbsp;</a></span>OnUserMessageBlocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserMessageBlocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_message_target.html">MessageTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_message_details.html">MessageDetails</a> &amp;&#160;</td>
          <td class="paramname"><em>details</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a message sent by a user to a channel, a user, or a server glob mask is blocked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the message. This can either be a channel, a user, or a server glob mask. </td></tr>
    <tr><td class="paramname">details</td><td>Details about the message such as the message text and type. See the <a class="el" href="class_message_details.html">MessageDetails</a> class for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a100db8d416d1484716999076880f63d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100db8d416d1484716999076880f63d5">&#9670;&nbsp;</a></span>OnUserPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>partmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user parts a channel. The details of the leaving user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user, and the details of the channel they have left is available in the variable <a class="el" href="class_channel.html">Channel</a> *channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memb</td><td>The channel membership being destroyed </td></tr>
    <tr><td class="paramname">partmessage</td><td>The part message, or an empty string (may be modified) </td></tr>
    <tr><td class="paramname">except_list</td><td>A list of users to not send to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af84ccce091b9f93467fae84f18fc9668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84ccce091b9f93467fae84f18fc9668">&#9670;&nbsp;</a></span>OnUserPostInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserPostInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user object has had their I/O hooks checked, their initial connection class assigned, and had a serializer set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The connecting user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ad7a612b402cbbfffea50fefdd8cbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad7a612b402cbbfffea50fefdd8cbe3">&#9670;&nbsp;</a></span>OnUserPostMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserPostMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_message_target.html">MessageTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_message_details.html">MessageDetails</a> &amp;&#160;</td>
          <td class="paramname"><em>details</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called immediately after a user sends a message to a channel, a user, or a server glob mask. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the message. This can either be a channel, a user, or a server glob mask. </td></tr>
    <tr><td class="paramname">details</td><td>Details about the message such as the message text and type. See the <a class="el" href="class_message_details.html">MessageDetails</a> class for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad35164fe098f2acdec99d3e242e585e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35164fe098f2acdec99d3e242e585e9">&#9670;&nbsp;</a></span>OnUserPostNick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserPostNick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldnick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after any nickchange, local or remote. This can be used to track users after nickchanges have been applied. Please note that although you can see remote nickchanges through this function, you should NOT make any changes to the <a class="el" href="class_user.html">User</a> if the user is a remote user as this may cause a desync. check user-&gt;server before taking any action (including returning nonzero from the method). Because this method is called after the nickchange is taken place, no return values are possible to indicate forbidding of the nick change. Use OnUserPreNick for this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user changing their nick </td></tr>
    <tr><td class="paramname">oldnick</td><td>The old nickname of the user before the nickchange </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c2b1fed6b47eda0305f04426db05baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2b1fed6b47eda0305f04426db05baf">&#9670;&nbsp;</a></span>OnUserPreInvite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnUserPreInvite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is about to invite another user into a channel, before any processing is done. Returning 1 from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. This is useful for modules which may want to filter invites to channels. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user who is issuing the INVITE </td></tr>
    <tr><td class="paramname">dest</td><td>The user being invited </td></tr>
    <tr><td class="paramname">channel</td><td>The channel the user is being invited to </td></tr>
    <tr><td class="paramname">timeout</td><td>The time the invite will expire (0 == never) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to deny the invite, 0 to check whether or not the user has permission to invite, -1 to explicitly allow the invite </dd></dl>

</div>
</div>
<a id="a35be5f8c388dc8a6e730842f990e0ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35be5f8c388dc8a6e730842f990e0ad9">&#9670;&nbsp;</a></span>OnUserPreJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnUserPreJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>privs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keygiven</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is about to join a channel, before any processing is done. Returning a value of 1 from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. This is useful for modules which may want to mimic +b, +k, +l etc. Returning -1 from this function forces the join to be allowed, bypassing restrictions such as banlists, invite, keys etc.</p>
<p>IMPORTANT NOTE!</p>
<p>If the user joins a NEW channel which does not exist yet, OnUserPreJoin will be called BEFORE the channel record is created. This will cause Channel* chan to be NULL. There is very little you can do in form of processing on the actual channel record at this point, however the channel NAME will still be passed in char* cname, so that you could for example implement a channel blacklist or whitelist, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user joining the channel </td></tr>
    <tr><td class="paramname">chan</td><td>If the channel is a new channel, this will be NULL, otherwise it will be a pointer to the channel being joined </td></tr>
    <tr><td class="paramname">cname</td><td>The channel name being joined. For new channels this is valid where chan is not. </td></tr>
    <tr><td class="paramname">privs</td><td>A string containing the users privileges when joining the channel. For new channels this will contain "o". You may alter this string to alter the user's modes on the channel. </td></tr>
    <tr><td class="paramname">keygiven</td><td>The key given to join the channel, or an empty string if none was provided </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 To prevent the join, 0 to allow it. </dd></dl>

</div>
</div>
<a id="a54fb5e86ea38f35095af102f40894c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fb5e86ea38f35095af102f40894c1b">&#9670;&nbsp;</a></span>OnUserPreKick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnUserPreKick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is about to be kicked. Returning a value of 1 from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user issuing the kick </td></tr>
    <tr><td class="paramname">memb</td><td>The channel membership of the user who is being kicked. </td></tr>
    <tr><td class="paramname">reason</td><td>The kick reason </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to prevent the kick, 0 to continue normally, -1 to explicitly allow the kick regardless of normal operation </dd></dl>

</div>
</div>
<a id="a13da0a736da61de2a73a36a6714d2b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13da0a736da61de2a73a36a6714d2b73">&#9670;&nbsp;</a></span>OnUserPreMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnUserPreMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_message_target.html">MessageTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_message_details.html">MessageDetails</a> &amp;&#160;</td>
          <td class="paramname"><em>details</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before a user sends a message to a channel, a user, or a server glob mask. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the message. This can either be a channel, a user, or a server glob mask. </td></tr>
    <tr><td class="paramname">details</td><td>Details about the message such as the message text and type. See the <a class="el" href="class_message_details.html">MessageDetails</a> class for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MOD_RES_ALLOW to explicitly allow the message, MOD_RES_DENY to explicitly deny the message, or MOD_RES_PASSTHRU to let another module handle the event. </dd></dl>

</div>
</div>
<a id="a3553e152e8cb2371f3ad99aeb61b8991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3553e152e8cb2371f3ad99aeb61b8991">&#9670;&nbsp;</a></span>OnUserPreNick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnUserPreNick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newnick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before local nickname changes. This can be used to implement Q-lines etc. If your method returns nonzero, the nickchange is silently forbidden, and it is down to your module to generate some meaningful output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The username changing their nick </td></tr>
    <tr><td class="paramname">newnick</td><td>Their new nickname </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to deny the change, 0 to allow </dd></dl>

</div>
</div>
<a id="a5b8387b28516ca01ebbb740325eb40ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8387b28516ca01ebbb740325eb40ee">&#9670;&nbsp;</a></span>OnUserPreQuit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnUserPreQuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>oper_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when before a user quits. The details of the exiting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user This event is only called when the user is fully registered when they quit. To catch raw disconnections, use the OnUserDisconnect method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is quitting </td></tr>
    <tr><td class="paramname">message</td><td>The user's quit message (as seen by non-opers) </td></tr>
    <tr><td class="paramname">oper_message</td><td>The user's quit message (as seen by opers) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a467945d27be3edec8fbd0de9a37a0c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467945d27be3edec8fbd0de9a37a0c31">&#9670;&nbsp;</a></span>OnUserQuit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserQuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oper_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user quits. The details of the exiting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user This event is only called when the user is fully registered when they quit. To catch raw disconnections, use the OnUserDisconnect method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is quitting </td></tr>
    <tr><td class="paramname">message</td><td>The user's quit message (as seen by non-opers) </td></tr>
    <tr><td class="paramname">oper_message</td><td>The user's quit message (as seen by opers) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeee48e5f4d4efbb826f462c1e5f4d0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee48e5f4d4efbb826f462c1e5f4d0ee">&#9670;&nbsp;</a></span>OnUserRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnUserRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is about to register their connection (e.g. before the user is sent the MOTD etc). Modules can use this method if they are performing a function which must be done before the actual connection is completed (e.g. ident lookups, dnsbl lookups, etc). Note that you should NOT delete the user record here by causing a disconnection! Use OnUserConnect for that instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user registering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to indicate user quit, 0 to continue </dd></dl>

</div>
</div>
<a id="abadd96f81a5cf5af438162f2b9a0c1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadd96f81a5cf5af438162f2b9a0c1f1">&#9670;&nbsp;</a></span>OnUserWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mod_result.html">ModResult</a> Module::OnUserWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_client_protocol_1_1_message.html">ClientProtocol::Message</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a message is about to be written to a user. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is having a message sent to them. </td></tr>
    <tr><td class="paramname">msg</td><td>The message which is being written to the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MOD_RES_ALLOW to explicitly allow the message to be sent, MOD_RES_DENY to explicitly deny the message from being sent, or MOD_RES_PASSTHRU to let another module handle the event. </dd></dl>

</div>
</div>
<a id="a88a2018354cc3e7d01d2ef73fbb95407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a2018354cc3e7d01d2ef73fbb95407">&#9670;&nbsp;</a></span>Prioritize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Module::Prioritize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when the hooks provided by a module need to be prioritised. </p>

</div>
</div>
<a id="a793782034272562b25f93b7a5b972513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793782034272562b25f93b7a5b972513">&#9670;&nbsp;</a></span>ReadConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::ReadConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_config_status.html">ConfigStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is called when you should reload module specific configuration: on boot, on a /REHASH and on module load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The current status, can be inspected for more information; also used for reporting configuration errors and warnings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aab94177da81fe7a68f37e48a554e272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab94177da81fe7a68f37e48a554e272f">&#9670;&nbsp;</a></span>dying</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Module::dying</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, this module will be unloaded soon, further unload attempts will fail Value is used by the <a class="el" href="class_module_manager.html">ModuleManager</a> internally, you should not modify it </p>

</div>
</div>
<a id="a5bbdc3c59248520549e5904bb402e2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbdc3c59248520549e5904bb402e2cb">&#9670;&nbsp;</a></span>ModuleDLLManager</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_l_l_manager.html">DLLManager</a>* Module::ModuleDLLManager</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference to the dlopen() value </p>

</div>
</div>
<a id="a4b9d41041b7b56a786064020e9c50c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9d41041b7b56a786064020e9c50c75">&#9670;&nbsp;</a></span>ModuleSourceFile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Module::ModuleSourceFile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>File that this module was loaded from </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="modules_8h_source.html">modules.h</a></li>
<li>src/modules.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
