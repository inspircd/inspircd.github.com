<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>InspIRCd: ModeParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">InspIRCd
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_mode_parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ModeParser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mode_8h_source.html">mode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ModeParser:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_mode_parser.png" usemap="#ModeParser_map" alt=""/>
  <map id="ModeParser_map" name="ModeParser_map">
<area href="structfakederef.html" alt="fakederef&lt; ModeParser &gt;" shape="rect" coords="0,0,160,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a910f3e7bf782ee7fb2b1a1b57a23588b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588b">ModeProcessFlags</a> { <a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588ba01b20347b43218a9b0504e0ace006914">MODE_NONE</a> = 0
, <a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588ba93f10e920df7067c7f31f575d7c97cab">MODE_MERGE</a> = 1
, <a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588baa51e1b726a9f96f67d732b7d6a603cd0">MODE_LOCALONLY</a> = 2
, <a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588baf12f4d962dd78d2d2c40351f2b91915e">MODE_CHECKACCESS</a> = 4
 }</td></tr>
<tr class="separator:a910f3e7bf782ee7fb2b1a1b57a23588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2d34cce6329da7e5086e621b6e3b05"><td class="memItemLeft" align="right" valign="top">typedef TR1NS::unordered_map&lt; std::string, <a class="el" href="class_mode_handler.html">ModeHandler</a> *, <a class="el" href="structirc_1_1insensitive.html">irc::insensitive</a>, <a class="el" href="structirc_1_1_str_hash_comp.html">irc::StrHashComp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a8f2d34cce6329da7e5086e621b6e3b05">ModeHandlerMap</a></td></tr>
<tr class="separator:a8f2d34cce6329da7e5086e621b6e3b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918288f165bc2e61c67b0bf24c1f9aa9"><td class="memItemLeft" align="right" valign="top"><a id="a918288f165bc2e61c67b0bf24c1f9aa9"></a>
typedef std::vector&lt; <a class="el" href="class_list_mode_base.html">ListModeBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ListModeList</b></td></tr>
<tr class="separator:a918288f165bc2e61c67b0bf24c1f9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c295cae5e49eb35c7ccf7bf67cc50f7"><td class="memItemLeft" align="right" valign="top"><a id="a6c295cae5e49eb35c7ccf7bf67cc50f7"></a>
typedef std::vector&lt; <a class="el" href="class_prefix_mode.html">PrefixMode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PrefixModeList</b></td></tr>
<tr class="separator:a6c295cae5e49eb35c7ccf7bf67cc50f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8457a072599031dd08fd7607ebf2122"><td class="memItemLeft" align="right" valign="top"><a id="ad8457a072599031dd08fd7607ebf2122"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>ModeProcessFlag</b></td></tr>
<tr class="separator:ad8457a072599031dd08fd7607ebf2122"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2cd0e5fc28292f90ff982973ebd13622"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a2cd0e5fc28292f90ff982973ebd13622">GetLastChangeList</a> () const</td></tr>
<tr class="separator:a2cd0e5fc28292f90ff982973ebd13622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfdaec24e085428326f12747334a57b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#acdfdaec24e085428326f12747334a57b">AddMode</a> (<a class="el" href="class_mode_handler.html">ModeHandler</a> *mh)</td></tr>
<tr class="separator:acdfdaec24e085428326f12747334a57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0f5ec49936812a01b4bec1f13be470"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a6c0f5ec49936812a01b4bec1f13be470">DelMode</a> (<a class="el" href="class_mode_handler.html">ModeHandler</a> *mh)</td></tr>
<tr class="separator:a6c0f5ec49936812a01b4bec1f13be470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e216f6ea7c03952c7db0782d2630748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a6e216f6ea7c03952c7db0782d2630748">AddModeWatcher</a> (<a class="el" href="class_mode_watcher.html">ModeWatcher</a> *mw)</td></tr>
<tr class="separator:a6e216f6ea7c03952c7db0782d2630748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b01721f55bd31a004557bf6372fa86e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a9b01721f55bd31a004557bf6372fa86e">DelModeWatcher</a> (<a class="el" href="class_mode_watcher.html">ModeWatcher</a> *mw)</td></tr>
<tr class="separator:a9b01721f55bd31a004557bf6372fa86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a5dd40880fc77347686e13bac933dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a75a5dd40880fc77347686e13bac933dc">Process</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *targetchannel, <a class="el" href="class_user.html">User</a> *targetuser, <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;changelist, ModeProcessFlag flags=<a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588ba01b20347b43218a9b0504e0ace006914">MODE_NONE</a>)</td></tr>
<tr class="separator:a75a5dd40880fc77347686e13bac933dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56a147f81683814b8aef3c603f2faf8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#ac56a147f81683814b8aef3c603f2faf8">ProcessSingle</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *targetchannel, <a class="el" href="class_user.html">User</a> *targetuser, <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;changelist, ModeProcessFlag flags=<a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588ba01b20347b43218a9b0504e0ace006914">MODE_NONE</a>, unsigned int beginindex=0)</td></tr>
<tr class="separator:ac56a147f81683814b8aef3c603f2faf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcc2d98a7916edeccaf1a6d4f570bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#acfcc2d98a7916edeccaf1a6d4f570bbe">ModeParamsToChangeList</a> (<a class="el" href="class_user.html">User</a> *user, ModeType type, const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;changelist, unsigned int beginindex=1, unsigned int endindex=UINT_MAX)</td></tr>
<tr class="separator:acfcc2d98a7916edeccaf1a6d4f570bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46a48ed67169090d4d8d3052b81e1e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mode_handler.html">ModeHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#ad46a48ed67169090d4d8d3052b81e1e5">FindMode</a> (const std::string &amp;modename, ModeType mt)</td></tr>
<tr class="separator:ad46a48ed67169090d4d8d3052b81e1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cf869139b1ba49594faba631441232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mode_handler.html">ModeHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#ad4cf869139b1ba49594faba631441232">FindMode</a> (unsigned const char modeletter, ModeType mt)</td></tr>
<tr class="separator:ad4cf869139b1ba49594faba631441232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8943403f8c362466907bfb9d77650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_prefix_mode.html">PrefixMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a4ec8943403f8c362466907bfb9d77650">FindPrefixMode</a> (unsigned char modeletter)</td></tr>
<tr class="separator:a4ec8943403f8c362466907bfb9d77650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f46dc53dfdc5dbd23763d9174483a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_prefix_mode.html">PrefixMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a08f46dc53dfdc5dbd23763d9174483a3">FindPrefix</a> (unsigned const char pfxletter)</td></tr>
<tr class="separator:a08f46dc53dfdc5dbd23763d9174483a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c68d35d3eb9496196fe59cefe8f711d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a7c68d35d3eb9496196fe59cefe8f711d">GiveModeList</a> (ModeType mt)</td></tr>
<tr class="separator:a7c68d35d3eb9496196fe59cefe8f711d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cc3037de41cde30b44fed326a33d3f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a20cc3037de41cde30b44fed326a33d3f">BuildPrefixes</a> (bool lettersAndModes=true)</td></tr>
<tr class="separator:a20cc3037de41cde30b44fed326a33d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cd9aa20814fb9b33ac3ac6b9d0e5d3"><td class="memItemLeft" align="right" valign="top">const ListModeList &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a84cd9aa20814fb9b33ac3ac6b9d0e5d3">GetListModes</a> () const</td></tr>
<tr class="separator:a84cd9aa20814fb9b33ac3ac6b9d0e5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adc4e9fe7b0aa4b6618f016f140ff1b"><td class="memItemLeft" align="right" valign="top">const PrefixModeList &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a3adc4e9fe7b0aa4b6618f016f140ff1b">GetPrefixModes</a> () const</td></tr>
<tr class="separator:a3adc4e9fe7b0aa4b6618f016f140ff1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab868818e889589a3d4aa151e35d97677"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_mode_parser.html#a8f2d34cce6329da7e5086e621b6e3b05">ModeHandlerMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#ab868818e889589a3d4aa151e35d97677">GetModes</a> (ModeType mt) const</td></tr>
<tr class="separator:ab868818e889589a3d4aa151e35d97677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7b39dab76678ed2509692456767e2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#aaf7b39dab76678ed2509692456767e2e">ShowListModeList</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, <a class="el" href="class_mode_handler.html">ModeHandler</a> *mh)</td></tr>
<tr class="separator:aaf7b39dab76678ed2509692456767e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structfakederef"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structfakederef')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structfakederef.html">fakederef&lt; ModeParser &gt;</a></td></tr>
<tr class="memitem:a593c1f235eb9c8624cf3f137df83149b inherit pub_methods_structfakederef"><td class="memItemLeft" align="right" valign="top"><a id="a593c1f235eb9c8624cf3f137df83149b"></a>
<a class="el" href="class_mode_parser.html">ModeParser</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> ()</td></tr>
<tr class="separator:a593c1f235eb9c8624cf3f137df83149b inherit pub_methods_structfakederef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2ad4facd5538662b892d91b96841479a"><td class="memItemLeft" align="right" valign="top"><a id="a2ad4facd5538662b892d91b96841479a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsModeChar</b> (char chr)</td></tr>
<tr class="separator:a2ad4facd5538662b892d91b96841479a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92a7eff25c3626371ff194ebd8f93a5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#ac92a7eff25c3626371ff194ebd8f93a5">CleanMask</a> (std::string &amp;mask)</td></tr>
<tr class="separator:ac92a7eff25c3626371ff194ebd8f93a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0cde2db571277dfaab18c7f6ad8ff8c6"><td class="memItemLeft" align="right" valign="top">static const ModeHandler::Id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a0cde2db571277dfaab18c7f6ad8ff8c6">MODEID_MAX</a> = 64</td></tr>
<tr class="separator:a0cde2db571277dfaab18c7f6ad8ff8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7595140326ba2b64289940c091473da6"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mode_parser.html#a7595140326ba2b64289940c091473da6">MODE_PARAM_MAX</a> = 250</td></tr>
<tr class="separator:a7595140326ba2b64289940c091473da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The mode parser handles routing of modes and handling of mode strings. It marshalls, controls and maintains both <a class="el" href="class_mode_watcher.html">ModeWatcher</a> and <a class="el" href="class_mode_handler.html">ModeHandler</a> classes, parses client to server MODE strings for user and channel modes, and performs processing for the 004 mode list numeric, amongst other things. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8f2d34cce6329da7e5086e621b6e3b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2d34cce6329da7e5086e621b6e3b05">&#9670;&nbsp;</a></span>ModeHandlerMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TR1NS::unordered_map&lt;std::string, <a class="el" href="class_mode_handler.html">ModeHandler</a>*, <a class="el" href="structirc_1_1insensitive.html">irc::insensitive</a>, <a class="el" href="structirc_1_1_str_hash_comp.html">irc::StrHashComp</a>&gt; <a class="el" href="class_mode_parser.html#a8f2d34cce6329da7e5086e621b6e3b05">ModeParser::ModeHandlerMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the container that maps mode names to ModeHandlers </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a910f3e7bf782ee7fb2b1a1b57a23588b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910f3e7bf782ee7fb2b1a1b57a23588b">&#9670;&nbsp;</a></span>ModeProcessFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588b">ModeParser::ModeProcessFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a910f3e7bf782ee7fb2b1a1b57a23588ba01b20347b43218a9b0504e0ace006914"></a>MODE_NONE&#160;</td><td class="fielddoc"><p>If only this flag is specified, the mode change will be global and parameter modes will have their parameters explicitly set (not merged). This is the default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a910f3e7bf782ee7fb2b1a1b57a23588ba93f10e920df7067c7f31f575d7c97cab"></a>MODE_MERGE&#160;</td><td class="fielddoc"><p>If this flag is set then the parameters of non-listmodes will be merged according to their conflict resolution rules. Does not affect user modes, channel modes without a parameter and listmodes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a910f3e7bf782ee7fb2b1a1b57a23588baa51e1b726a9f96f67d732b7d6a603cd0"></a>MODE_LOCALONLY&#160;</td><td class="fielddoc"><p>If this flag is set then the linking module will ignore the mode change and not send it to other servers. The mode change will be processed locally and sent to local user(s) as usual. </p>
</td></tr>
<tr><td class="fieldname"><a id="a910f3e7bf782ee7fb2b1a1b57a23588baf12f4d962dd78d2d2c40351f2b91915e"></a>MODE_CHECKACCESS&#160;</td><td class="fielddoc"><p>If this flag is set then the mode change will be subject to access checks. For more information see the documentation of the <a class="el" href="class_prefix_mode.html">PrefixMode</a> class, <a class="el" href="class_mode_handler.html#ae84b99b17337edca69ea3d220ebe483d">ModeHandler::ranktoset</a> and <a class="el" href="class_mode_handler.html#adc5578a8e2bbdac4ebf84ce5a4b31b6d">ModeHandler::AccessCheck()</a>. Modules may explicitly allow a mode change regardless of this flag by returning MOD_RES_ALLOW from the OnPreMode hook. Only affects channel mode changes. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acdfdaec24e085428326f12747334a57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfdaec24e085428326f12747334a57b">&#9670;&nbsp;</a></span>AddMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModeParser::AddMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mode_handler.html">ModeHandler</a> *&#160;</td>
          <td class="paramname"><em>mh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a mode to the mode parser. Throws a <a class="el" href="class_module_exception.html">ModuleException</a> if the mode cannot be added. </p>

</div>
</div>
<a id="a6e216f6ea7c03952c7db0782d2630748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e216f6ea7c03952c7db0782d2630748">&#9670;&nbsp;</a></span>AddModeWatcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModeParser::AddModeWatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mode_watcher.html">ModeWatcher</a> *&#160;</td>
          <td class="paramname"><em>mw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a mode watcher. A mode watcher is triggered before and after a mode handler is triggered. See the documentation of class <a class="el" href="class_mode_watcher.html">ModeWatcher</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mw</td><td>The <a class="el" href="class_mode_watcher.html">ModeWatcher</a> you want to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20cc3037de41cde30b44fed326a33d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cc3037de41cde30b44fed326a33d3f">&#9670;&nbsp;</a></span>BuildPrefixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ModeParser::BuildPrefixes </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lettersAndModes</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the PREFIX=(ohv)%+ section of the 005 numeric, or just the "@%+" part if the parameter false </p>

</div>
</div>
<a id="ac92a7eff25c3626371ff194ebd8f93a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92a7eff25c3626371ff194ebd8f93a5">&#9670;&nbsp;</a></span>CleanMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModeParser::CleanMask </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tidy a banmask. This makes a banmask 'acceptable' if fields are left out. E.g.</p>
<p>nick -&gt; nick!*@*</p>
<p>nick!ident -&gt; nick!ident@*</p>
<p>host.name -&gt; <em>!</em>@host.name</p>
<p>ident@host.name -&gt; *!ident@host.name</p>
<p>This method can be used on both IPV4 and IPV6 user masks. </p>

</div>
</div>
<a id="a6c0f5ec49936812a01b4bec1f13be470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0f5ec49936812a01b4bec1f13be470">&#9670;&nbsp;</a></span>DelMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ModeParser::DelMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mode_handler.html">ModeHandler</a> *&#160;</td>
          <td class="paramname"><em>mh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a mode from the mode parser. When a mode is deleted, the mode handler will be called for every user (if it is a user mode) or for every channel (if it is a channel mode) to unset the mode on all objects. This prevents modes staying in the system which no longer exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mh</td><td>The mode handler to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mode was successfully removed. </dd></dl>

</div>
</div>
<a id="a9b01721f55bd31a004557bf6372fa86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b01721f55bd31a004557bf6372fa86e">&#9670;&nbsp;</a></span>DelModeWatcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ModeParser::DelModeWatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mode_watcher.html">ModeWatcher</a> *&#160;</td>
          <td class="paramname"><em>mw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a mode watcher. A mode watcher is triggered before and after a mode handler is triggered. See the documentation of class <a class="el" href="class_mode_watcher.html">ModeWatcher</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mw</td><td>The <a class="el" href="class_mode_watcher.html">ModeWatcher</a> you want to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="class_mode_watcher.html">ModeWatcher</a> was deleted correctly </dd></dl>

</div>
</div>
<a id="ad46a48ed67169090d4d8d3052b81e1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46a48ed67169090d4d8d3052b81e1e5">&#9670;&nbsp;</a></span>FindMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mode_handler.html">ModeHandler</a> * ModeParser::FindMode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>modename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModeType&#160;</td>
          <td class="paramname"><em>mt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the mode handler for a given mode name and type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modename</td><td>The mode name to search for. </td></tr>
    <tr><td class="paramname">mt</td><td>Type of mode to search for, user or channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="class_mode_handler.html">ModeHandler</a> class, or NULL of there isn't a handler for the given mode name. </dd></dl>

</div>
</div>
<a id="ad4cf869139b1ba49594faba631441232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cf869139b1ba49594faba631441232">&#9670;&nbsp;</a></span>FindMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mode_handler.html">ModeHandler</a> * ModeParser::FindMode </td>
          <td>(</td>
          <td class="paramtype">unsigned const char&#160;</td>
          <td class="paramname"><em>modeletter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModeType&#160;</td>
          <td class="paramname"><em>mt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the mode handler for a given mode and type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modeletter</td><td>mode letter to search for </td></tr>
    <tr><td class="paramname">mt</td><td>type of mode to search for, user or channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_mode_handler.html">ModeHandler</a> class, or NULL of there isn't a handler for the given mode </dd></dl>

</div>
</div>
<a id="a08f46dc53dfdc5dbd23763d9174483a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f46dc53dfdc5dbd23763d9174483a3">&#9670;&nbsp;</a></span>FindPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_prefix_mode.html">PrefixMode</a> * ModeParser::FindPrefix </td>
          <td>(</td>
          <td class="paramtype">unsigned const char&#160;</td>
          <td class="paramname"><em>pfxletter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a mode handler by its prefix. If there is no mode handler with the given prefix, NULL will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfxletter</td><td>The prefix to find, e.g. '@' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mode handler which handles this prefix, or NULL if there is none. </dd></dl>

</div>
</div>
<a id="a4ec8943403f8c362466907bfb9d77650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec8943403f8c362466907bfb9d77650">&#9670;&nbsp;</a></span>FindPrefixMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_prefix_mode.html">PrefixMode</a> * ModeParser::FindPrefixMode </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>modeletter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the mode handler for the given prefix mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modeletter</td><td>The mode letter to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="class_prefix_mode.html">PrefixMode</a> or NULL if the mode wasn't found or it isn't a prefix mode </dd></dl>

</div>
</div>
<a id="a2cd0e5fc28292f90ff982973ebd13622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd0e5fc28292f90ff982973ebd13622">&#9670;&nbsp;</a></span>GetLastChangeList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a>&amp; ModeParser::GetLastChangeList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the last mode change to be processed. </p>

</div>
</div>
<a id="a84cd9aa20814fb9b33ac3ac6b9d0e5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cd9aa20814fb9b33ac3ac6b9d0e5d3">&#9670;&nbsp;</a></span>GetListModes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ListModeList&amp; ModeParser::GetListModes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of all mode handlers that inherit from <a class="el" href="class_list_mode_base.html">ListModeBase</a> </p><dl class="section return"><dt>Returns</dt><dd>A list containing <a class="el" href="class_list_mode_base.html">ListModeBase</a> modes </dd></dl>

</div>
</div>
<a id="ab868818e889589a3d4aa151e35d97677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab868818e889589a3d4aa151e35d97677">&#9670;&nbsp;</a></span>GetModes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_mode_parser.html#a8f2d34cce6329da7e5086e621b6e3b05">ModeHandlerMap</a>&amp; ModeParser::GetModes </td>
          <td>(</td>
          <td class="paramtype">ModeType&#160;</td>
          <td class="paramname"><em>mt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a mode name -&gt; ModeHandler* map containing all modes of the given type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mt</td><td>Type of modes to return, MODETYPE_USER or MODETYPE_CHANNEL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of mode handlers of the given type </dd></dl>

</div>
</div>
<a id="a3adc4e9fe7b0aa4b6618f016f140ff1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adc4e9fe7b0aa4b6618f016f140ff1b">&#9670;&nbsp;</a></span>GetPrefixModes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const PrefixModeList&amp; ModeParser::GetPrefixModes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of all prefix modes </p><dl class="section return"><dt>Returns</dt><dd>A list containing all prefix modes </dd></dl>

</div>
</div>
<a id="a7c68d35d3eb9496196fe59cefe8f711d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c68d35d3eb9496196fe59cefe8f711d">&#9670;&nbsp;</a></span>GiveModeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ModeParser::GiveModeList </td>
          <td>(</td>
          <td class="paramtype">ModeType&#160;</td>
          <td class="paramname"><em>mt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a list of modes, comma separated by type: 1; Listmodes EXCEPT those with a prefix 2; Modes that take a param when adding or removing 3; Modes that only take a param when adding 4; Modes that dont take a param </p>

</div>
</div>
<a id="acfcc2d98a7916edeccaf1a6d4f570bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcc2d98a7916edeccaf1a6d4f570bbe">&#9670;&nbsp;</a></span>ModeParamsToChangeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModeParser::ModeParamsToChangeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModeType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>changelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>beginindex</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>endindex</em> = <code>UINT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn a list of parameters compatible with the format of the MODE command into <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> form. All modes are processed, regardless of max modes. Unknown modes are skipped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The source of the mode change, can be a server user. Error numerics are sent to this user. </td></tr>
    <tr><td class="paramname">type</td><td>MODETYPE_USER if this is a user mode change or MODETYPE_CHANNEL if this is a channel mode change. </td></tr>
    <tr><td class="paramname">parameters</td><td>List of strings describing the mode change to convert to a ChangeList. Must be using the same format as the parameters of a MODE command. </td></tr>
    <tr><td class="paramname">changelist</td><td>ChangeList object to populate. </td></tr>
    <tr><td class="paramname">beginindex</td><td>Index of the first element that is part of the MODE list in the parameters container. Defaults to 1. </td></tr>
    <tr><td class="paramname">endindex</td><td>Index of the first element that is not part of the MODE list. By default, the entire container is considered part of the MODE list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75a5dd40880fc77347686e13bac933dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a5dd40880fc77347686e13bac933dc">&#9670;&nbsp;</a></span>Process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModeParser::Process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>targetchannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>targetuser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>changelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModeProcessFlag&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588ba01b20347b43218a9b0504e0ace006914">MODE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a list of mode changes entirely. If the mode changes do not fit into one MODE line then multiple MODE lines are generated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The source of the mode change, can be a server user. </td></tr>
    <tr><td class="paramname">targetchannel</td><td><a class="el" href="class_channel.html">Channel</a> to apply the mode change on. NULL if changing modes on a channel. </td></tr>
    <tr><td class="paramname">targetuser</td><td><a class="el" href="class_user.html">User</a> to apply the mode change on. NULL if changing modes on a user. </td></tr>
    <tr><td class="paramname">changelist</td><td>Modes to change in form of a <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a>. </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags controlling how the mode change is processed, defaults to MODE_NONE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac56a147f81683814b8aef3c603f2faf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56a147f81683814b8aef3c603f2faf8">&#9670;&nbsp;</a></span>ProcessSingle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ModeParser::ProcessSingle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>targetchannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>targetuser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>changelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModeProcessFlag&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="class_mode_parser.html#a910f3e7bf782ee7fb2b1a1b57a23588ba01b20347b43218a9b0504e0ace006914">MODE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>beginindex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a single MODE line's worth of mode changes, taking max modes and line length limits into consideration. Return value indicates how many modes were processed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The source of the mode change, can be a server user. </td></tr>
    <tr><td class="paramname">targetchannel</td><td><a class="el" href="class_channel.html">Channel</a> to apply the mode change on. NULL if changing modes on a channel. </td></tr>
    <tr><td class="paramname">targetuser</td><td><a class="el" href="class_user.html">User</a> to apply the mode change on. NULL if changing modes on a user. </td></tr>
    <tr><td class="paramname">changelist</td><td>Modes to change in form of a <a class="el" href="class_modes_1_1_change_list.html">Modes::ChangeList</a>. May not process the entire list due to MODE line length and max modes limitations. </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags controlling how the mode change is processed, defaults to MODE_NONE. </td></tr>
    <tr><td class="paramname">beginindex</td><td>Index of the first element in changelist to process. Mode changes before the element with this index are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of mode changes processed from changelist. </dd></dl>

</div>
</div>
<a id="aaf7b39dab76678ed2509692456767e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7b39dab76678ed2509692456767e2e">&#9670;&nbsp;</a></span>ShowListModeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModeParser::ShowListModeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mode_handler.html">ModeHandler</a> *&#160;</td>
          <td class="paramname"><em>mh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Show the list of a list mode to a user. Modules can deny the listing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td><a class="el" href="class_user.html">User</a> to show the list to. </td></tr>
    <tr><td class="paramname">chan</td><td><a class="el" href="class_channel.html">Channel</a> to show the list of. </td></tr>
    <tr><td class="paramname">mh</td><td>List mode to show the list of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2cc9a5acc27894eca909d15d34620a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc9a5acc27894eca909d15d34620a07">&#9670;&nbsp;</a></span>list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_list_mode_base.html">ListModeBase</a>*&gt; ModeParser::list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of mode handlers that inherit from <a class="el" href="class_list_mode_base.html">ListModeBase</a> </p>

</div>
</div>
<a id="a7595140326ba2b64289940c091473da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7595140326ba2b64289940c091473da6">&#9670;&nbsp;</a></span>MODE_PARAM_MAX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ModeParser::MODE_PARAM_MAX = 250</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum length of a mode parameter. </p>

</div>
</div>
<a id="a0cde2db571277dfaab18c7f6ad8ff8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cde2db571277dfaab18c7f6ad8ff8c6">&#9670;&nbsp;</a></span>MODEID_MAX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ModeHandler::Id ModeParser::MODEID_MAX = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum number of modes which can be created. </p>

</div>
</div>
<a id="a49ddb2851a8e5c28b0fbf391764fb65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ddb2851a8e5c28b0fbf391764fb65c">&#9670;&nbsp;</a></span>prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_prefix_mode.html">PrefixMode</a>*&gt; ModeParser::prefix</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of mode handlers that inherit from <a class="el" href="class_prefix_mode.html">PrefixMode</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="mode_8h_source.html">mode.h</a></li>
<li>src/mode.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
